Code:

``` python
import sys
sys.setrecursionlimit(20000)
def func1(arr, low, high):
    if low < high:
        pi = func2(arr, low, high)
        func1(arr, low, pi-1)
        func1(arr, pi + 1, high)
def func2(array, start, end):
    p = array[start]
    low = start + 1
    high = end
    while True:
        while low <= high and array[high] >= p:
            high = high - 1
        while low <= high and array[low] <= p:
            low = low + 1
        if low <= high:
            array[low], array[high] = array[high], array[low]
        else:
            break
    array[start], array[high] = array[high], array[start]
    return high
```

## Heading 3: Questions:
1. Explain what the code does and perform an average-case complexity analysis. Describe
the process, not just the result. (2 pts)
2. Test the code on all the inputs at:
https://raw.githubusercontent.com/ldklab/ensf338w23/main/assignme
nts/assignment2/ex2.json
Plot timing results. Provide your timing/plotting code as ex2.2.py. (2 pts)
3. Compare the timing results with the result of the complexity analysis. Is the result
consistent? Why? (2 pts)
4. Change the code – if possible – to improve its performance on the input given in point 2.
If possible, provide your code as ex2.4.py and plot the improved results. If not possible,
explain why. (2 pts)
5. Alter the inputs given in point 2 – if possible - to improve the performance of the code
given in the text of the question. The new inputs should contain all the elements of the
old inputs, and nothing more. Plot the results and provide the new inputs as ex2.5.json).
If not possible, explain why. (2 pts)


## Heading 3: Answers:
1. This code uses the quick sort method to sort arrays. Quick sort works by recursively subdividing the array and
ordering each subdivision. The arrays are sorted around the pivot point, which in this case is the first element of
the array. The subdivision will continue until the length of all sub-arrays have a single element.

__Average Case Complexity Analysis__:
